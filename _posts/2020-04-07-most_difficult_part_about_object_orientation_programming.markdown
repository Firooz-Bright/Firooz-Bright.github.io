---
layout: post
title:      "Most difficult part about  Object Orientation Programming"
date:       2020-04-07 02:57:18 -0400
permalink:  most_difficult_part_about_object_orientation_programming
---

The most difficult part of learning and even teaching the OOP is when you try to explain the architect of memory and came to believe that computer doesn't care if your write something wrong because everything is related to memory and good practice of OOP is to know how memory works and then how the language you are writing OOP deals with memory. 

![](https://miro.medium.com/max/1400/1*puhZOwtOxzGFPZUTvuWejQ.jpeg)
 
Computers just know that there is this stuff called memory, and memory contains a bunch of numbers in it.
The ultimate goal of every software developer should be to write reliable code. Nothing else matters if the code is buggy and unreliable. And what is the best way to write code that is reliable? Simplicity. Simplicity is the opposite of complexity. Therefore our first and foremost responsibility as software developers should be to reduce code complexity.
The biggest obstacle to creating program is our brain is thinking Procedural and we are going to code in OOP, so grasping the idea is hard because we want to make Objects in memory which are gonna be a different way to treat the data, we can have abstracted and we can write once a program and use it for a lot with little editing or modification. This is how we have to understand learning or teaching OOP is not easier than we think. 

Thankfully, Deborah J. Armstrong made a survey of how people use the term (The Quarks of Object-Oriented Development) and came up with 8 fundamental building blocks.

Five are structural:

Abstraction Representing reality in a simplified form by removing certain distinctions so that we can see the commonalities.
Class A generalized description of similar objects that share a common structure and behavior.
Encapsulation Data and behavior are defined within an object and separated from everything else, protecting the internal representation of the object.
Inheritance Allows the attributes and methods of one class to be based on another existing class.
Object An individual, identifiable item, either real or abstract, which contains information about itself and the descriptions of its manipulations.
Three are behavioral:

1. Message The process by which an object sends Passing information or invokes a method.
2. Method Accessing, setting or manipulating an object’s information.
3. Polymorphism Different objects can respond to the same message and implement them appropriately.

![](https://i.ytimg.com/vi/NUl8lcbeN2Y/maxresdefault.jpg)
 
But still, it is hard to imagine for the human mind which everything is procedural even in our daily life. First of all, at least in "pure OOP". where everything is an object, you have to twist your mind into a rather unnatural configuration to think of a number as an intelligent object instead of just a value .... since, in reality, 21 (for example) really is just a value. This becomes especially problematic when on one hand you're told that a big advantage of OOP is modeling reality more closely, but you start off by taking what looks an awful lot like an LSD-inspired view of even the most basic and obvious parts of reality.
 
 ![](https://beginnersbook.com/wp-content/uploads/2013/04/OOPs-Concepts-Message-Passing.jpg)
 
On the other hand inheritance in OOP doesn't follow most people's mental models very closely either. For most people, classifying things most specifically does not have anywhere close to the absolute rules necessary to create a class hierarchy that works. In particular, creating a class D that inherits from another class B means that objects of class D share absolutely, positively all the characteristics of class B. class D can add new and different characteristics of its own, but all the characteristics of class B must remain intact.

By contrast, when people classify things mentally, they typically follow a much looser model. For one example, if a person makes some rules about what constitutes a class of objects, it's pretty typical that almost anyone rule can be broken as long as enough other rules are followed. Even the few rules that can't really be broken can almost always be "stretched" a little bit anyway.   
                   
 The disadvantages of OOP is :It’s impossible for you to stay on top of it all. The fact is: You’ll never be able to say that you’re done learning about it. That’s what makes learning a terrible .

A good practice isn’t vague. It’s measurable, concrete and attainable. You can say with confidence that you either succeeded or failed at doing it.

Learning doesn’t work that way. There’s no test in the world that can measure how much object-oriented programming you’ve learned. There’s no goal post that you can reach. You can’t flick a switch and go from “Not knowing it” to “Knowing it”.

It’s a gradual and continuous process.

You shouldn’t worry about the fact that you got sidetracked. Instead, you should bring the focus back to writing code, to building something. That’s how you’ll learn object-oriented programming.

![](https://files.realpython.com/media/Object-Oriented-Programming-OOP-in-Python-3_Watermarked.0d29780806d5.jpg)

You have to sit down and do the work. You shouldn’t worry about doing it wrong. Or that you’ve got no idea what you’re doing. It doesn’t matter in the long run.
 
 ![](https://cdn.educba.com/academy/wp-content/uploads/2019/02/Advantages-of-OOP.jpg)
 
The advantage is that the things that belong together are put together in code,however there are lots of Developer who hates OOP but it gives you lots of advantages: 
 
* inheritance
* operator overloading
* type safety
* encapsulation
* polymorphism
* dynamic binding
* constructors/destructors
* classes
* instances
* nodes

Eventualy for me the power of OOP is the flexibility of the data structures and the ability to assign memory to each-other.


